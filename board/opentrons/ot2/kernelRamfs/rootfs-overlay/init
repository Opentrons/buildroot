#!/bin/sh

################################################################################################
# Opentrons KernelRamFS
################################################################################################
#
# The KernelRamfs is a minimal kernel + initramfs whos purpose is to update
# the boot partition with the contents of /boot/boot.tar.xz on the rootfs. 
# The primary use case for this is to update out of 6.1, as well as provide
# a mechanism to allow us to update the boot partition in the future.

# There is a new u-boot env flag 'kernelramfs' which determines if we boot 
# into kernelRamfs or the regular kernel, by default this is set to 0 so the system
# boots into the normal kernel. However, it can be set to a different value
# from userspace to change the logic as followed.
#
# kernelramfs = "0"   - load kernel at /boot/kernel
# kernelramfs = "1"   - load kernelRamfs at /boot/kernelRamfs and drop into recovery shell
# kernelramfs > "1"   - load kernelRamfs at /boot/kernelRamfs and update the boot partition
#                       with the contents of the /boot/boot.tar.xz file in the active rootfs
#                       partition (2,3) as determined by the 'ot2part' u-boot env variable.
#                       Automatically restarts the system and attempts to boot.
################################################################################################

set -e pipefail
trap reboot_system EXIT

reboot_system() {
   if [ $? -eq 1 ]; then
      ot2part=$(fw_printenv -n ot2part)
      echo "current partition ${ot2part}"
      if [ $ot2part -eq 2 ]; then ot2part=3;
      elif [ $ot2part -eq 3 ]; then ot2part=2; fi
      echo "Something went wrong reverting to /dev/mmcblkp${ot2part}."
      fw_setenv ot2part $ot2part
   fi

   # reset the kernelramfs var so we dont boot back in here
   fw_setenv kernelramfs 0

   # unset trap so we dont capture umount
   trap - EXIT

   # Only unmount the boot partition, unmounting the rootfs housing kernelramfs causes kernel panic.
   echo "Unmount the boot partition"
   umount /dev/mmcblk0p1

   echo "Rebooting the system"
   sleep 5
   exec reboot -nf
}

echo "Welcome to Opentrons kernelRamfs"

echo "Setting up ramdisk"
# Mount the /proc, /sys and /dev filesystems.
mount -t proc none /proc
mount -t sysfs none /sys
mount -t devtmpfs devtmpfs /dev

# create lock dir for fw_printenv
mkdir -p /run/lock

# sleep to give time for the sdhc to be setup
sleep 10

BOOTFS=/dev/mmcblk0p1
# mount the boot partition if it exists
ls $BOOTFS > /dev/null
mount $BOOTFS /boot

# if the 'kernelramfs' env flag does not exist, then its our first
# time here and we need to set it along with any other variables in
# the /boot/set-u-boot-vars file. The reason we need this
# file is because we need to set the 'bootdelay' var to -2, so
# the non-refresh ot2 does not get interrupted during boot. We cant
# set u-boot variables to negative numbers directly, so we are
# using a config file instead.
if ! fw_printenv | grep kernelramfs > /dev/null; then
   fw_setenv --script /etc/set-u-boot-vars
fi

# if kernelramfs env flag is set to "1" jump the shell
start_recovery=$(fw_printenv -n kernelramfs)
if [ $start_recovery -eq "1" ]; then
    echo "Entering KernelRamfs"
    setsid sh -c 'exec sh </dev/tty1 >/dev/tty1 2>&1'
    reboot_system
fi

echo "Getting active rootfs partition"
ROOTFS=$(grep -o "root=.*" /proc/cmdline | grep -o "/dev/mmcblk0p.")
echo "Mounting active rootfs partiton - $ROOTFS"
mount $ROOTFS /rootfs

# create partitions incase they dont exist
mkdir -p /rootfs/boot

echo "Verifying that kernel files exist."
# ls will throw a non-zero exit code if the files dont exist,
# which will be captured by trap and the system will reboot
ls /rootfs/boot/kernel > /dev/null
ls /rootfs/boot/kernelRamfs > /dev/null
ls /rootfs/boot/zImage > /dev/null

echo "Veryfying boot.tar.xz contents"
# check that the boot tarball exists
ls /rootfs/boot/boot.tar.xz > /dev/null

# list of files that need to be in the tarball
required_boot_files="dtb dtbo kernelRamfs.dtb bootcode.bin \
start.elf fixup.dat config.txt boot.scr u-boot.bin"

# check that the boot.tar.xz contains the required files.
# if a file does not exist grep will throw a non-zero exit code
# which will be captured by trap and the system will reboot.
bootfiles=$(tar -Jtf /rootfs/boot/boot.tar.xz)
for file in $required_boot_files; do
   echo "Checking if ${file} exists"
   echo $bootfiles | grep -wqo "${file}"
   echo "found ${file} file(s)"
done

# if we made it here, then all required files exist in the rootfs and we can continue.
echo "Extracting files to boot partition..."
tar -Jxf /rootfs/boot/boot.tar.xz -C /boot/

# the dtb will have changed so delete the fdt_addr var so we recreate it in uboot
fw_setenv fdt_addr

echo "Boot partition update complete."
reboot_system
