#!/bin/sh

###################
# Opentrons KernelRamFS     
###################
#
# The purpose of this init script is to allow
# one stage updates when updating from buildroot
# with an old kernel to buildroot with new kernel.
# 
# The reason why we need to do that is because the device tree (dtb)
# and device tree overlays (dtbo) files have changed and so a clean
# update causes the device to get bricked needing a reflash.
#
# The way we accomplish this is by shipping the rootfs with this kernelRamfs
# as the zImage in the /boot dir, as well as the actual kernel image.
# When the rootfs is written in the inactive partition and the system
# restarts we boot into this kernelRamfs. From here we mount the active
# rootfs partition, copy the dtb(s) + overlays + config.txt files from
# /boot to the boot partition and rename the kernel. We then set the 
# uboot env variable 'ot2part' to the current part and reboot. Once 
# the system reboots it will boot into the new kernel.
###################

set -e pipefail
trap recovery EXIT

recovery() {
   # drop into recovery shell if we get a non-zero exit status
   [ $? != 1 ] && exit
   echo "Something went wrong, entering recovery..."
   setsid sh -c 'exec sh </dev/tty1 >/dev/tty1 2>&1'
}

echo "Welcome to Opentrons kernelRamfs"

echo "Setting up ramdisk"
# Mount the /proc, /sys and /dev filesystems.
mount -t proc none /proc
mount -t sysfs none /sys
mount -t devtmpfs devtmpfs /dev

# create lock dir for fw_printenv
mkdir -p /run/lock

# sleep to give time for the sdhc to be setup
sleep 10

# mount the boot partition
mount /dev/mmcblk0p1 /boot

# if the 'kernelramfs' env flag does not exist,
# then its our first time here and we need to set it.
if ! fw_printenv | grep kernelramfs > /dev/null; then
   fw_setenv kernelramfs 0
fi

# if kernelramfs env flag is set to "1" jump the shell
start_recovery=$(fw_printenv -n kernelramfs)
if [ $start_recovery -eq "1" ]; then
    echo "Entering KernelRamfs"
    setsid sh -c 'exec sh </dev/tty1 >/dev/tty1 2>&1'
    echo "Leaving KernelRamfs"
    reboot -f
fi

echo "Ramdisk setup, starting update"
# find the active rootfs and mount it
ROOTFS=$(cat /proc/cmdline | grep -o "/dev/mmcblk0p.")
echo "Mounting active rootfs partiton - $ROOTFS"
mount $ROOTFS /rootfs

# create partitions incase they dont exist
mkdir -p /rootfs/boot
mkdir -p /rootfs/overlays/overlays
mkdir -p /boot/overlays

# use ls command to make sure the update files exist
# redirect output to null so we arent flooded with messages
# we dont have brace expantion so have to call ls multiple times.
ls /boot/*.dtb > /dev/null
ls /boot/overlays/*.dtbo > /dev/null
ls /boot/config.txt > /dev/null
ls /boot/boot.scr > /dev/null

echo "Copying files to boot partition..."
# copy the dtb(s) + overlays + config.txt + boot.scr from rootfs to boot
cp /rootfs/boot/*.dtb /boot/
cp /rootfs/boot/overlays/overlays/*.dtbo /boot/overlays/
cp /rootfs/boot/config.txt /boot/
cp /rootfs/boot/boot.scr /boot/

# We need to set the ot2part env variable so uboot does not revert to
# the old partition once we restart. Since we want to boot on the same
# partition but with updated kernel.
boot_part=$(fw_printenv -n ot2part)
echo "Setting ot2part to $boot_part"
fw_setenv ot2part $boot_part

# unmount the partitions and reboot
echo "Unmounting boot and rootfs partitions"
umount /dev/mmcblk0p1
umount $ROOTFS

echo "Opentrons KernalRamfs finished successfully, restarting..."
sleep 2
reboot -f
