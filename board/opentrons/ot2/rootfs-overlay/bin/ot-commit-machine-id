#!/usr/bin/env sh

# This script gives the system its persistent machine-id, as part of first-boot
# setup.
#
# /etc/machine-id should contain a persistent, unique identifier for this
# device. Userspace programs like journald rely on this.
#
# On our fresh SD card images, /etc/machine-id is unpopulated. When systemd sees
# this, it autogenerates a transient machine-id and overlays it, so other
# userspace programs can rely on its presence.
#
# +------------------------------------------+
# | temp file, populated, created by systemd |
# +------------------------------------------+
#                      |
#                 bind-mounted
#                      |
#                      V
#           +---------------------+
#           | regular file, empty |
#           +---------------------+
#                      |
#                on filesystem
#                      |
#                      V
#               /etc/machine-id
#
# Normally, systemd can, on its own, write back this autogenerated machine-id to
# persistent storage. (See systemd-machine-id-commit.service.)
# But in our case, that doesn't work because it expects our active rootfs to be
# eventually writable, whereas we want to keep it always read-only.
#
# This script instead persists the current machine-id by:
#
# 1) Mounting our active rootfs in an additional, second place, off to the side
#    where nothing can accidentally access it. And making that mount writable.
# 2) Updating the underlying /etc/machine-id file through that second mount.
#
# Then, in future boots, the underlying /etc/machine-id file will be populated,
# and systemd will reuse it instead of autogenerating a new one.
#
# See also the update-server service, which needs to apply a similar fixup to
# system update images.


set -eu -o pipefail

MACHINE_ID_FILE=/etc/machine-id


# todo(mm, 2021-02-25): Instead of checking like this, should we configure the
# service to only run on systemd's notion of "first boot"? 
function already_committed {
    # Return success if we've already committed the machine-id in a prior boot,
    # failure otherwise.

    # If $MACHINE_ID_FILE was unpopulated at the beginning of this
    # boot, then systemd will have bind-mounted a tmpfs file atop it.
    ! findmnt --mountpoint "$MACHINE_ID_FILE" > /dev/null
}

function clean_up {
    umount "$rw_remount_point"
    rmdir "$rw_remount_point"
    # todo(mm, 2021-02-25): Should these tolerate failure?
    # todo(mm, 2021-02-25): Does this need an explicit status code return ($?)?
}


if already_committed
then
    printf "machine-id"
    printf " \"$(cat "$MACHINE_ID_FILE")\""
    printf " already committed."
    printf " Exiting without doing anything.\n"
    exit
fi

# todo(mm, 2021-02-25): Include this script's name in the template.
rw_remount_point=$(mktemp -d)

# fixme(mm, 2021-02-25): Commented out for debugging.
# trap clean_up EXIT

# Due to a quirk in how mount works, this needs to be two separate commands or
# the "-o rw" won't work. See the "mount --bind" description in man(8) mount.
mount --bind / "$rw_remount_point"
mount -o remount,rw "$rw_remount_point"

rw_machine_id_file="$rw_remount_point/$MACHINE_ID_FILE"

# At this point:
#
# If we've already committed the machine-id, $rw_machine_id_file exists and
# points to the same underlying file as $MACHINE_ID_FILE.
#
# If we haven't, $rw_machine_id_file doesn't exist at all.

# This write gets mirrored to $MACHINE_ID_FILE.
#
# For this boot, that file will still be shadowed by systemd's tmpfs bind mount,
# which is fine because their contents should be identical.
# For subsequent boots, systemd will notice that /etc/machine-id is already
# populated and avoid creating the tmpfs bind mount.
#
# Unfortunately, we can't use cp to make this write atomic: it errors with
# "device or resource busy." I think that's because the original file is serving
# as the mount point for systemd's tmpfs bind mount, so it can't be removed or
# replaced.
cat "$MACHINE_ID_FILE" > "$rw_machine_id_file"

printf "Committed machine-id \"$(cat "$rw_machine_id_file")\".\n"
