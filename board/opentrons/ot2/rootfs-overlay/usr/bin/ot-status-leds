#!/usr/bin/env python3

# Monitor system status and update LEDs accordingly
# D2 ) Ethernet LED  : STATUS_LED_1  => Pin15    => bcm22
# D3 ) Wifi LED      : STATUS_LED_2  => Pin27    => bcm00
# D4 ) Heartbeat LED : STATUS_LED_3  => Pin22    => bcm25
# D5 ) UNDEFINED_LED : STATUS_LED_4  => Pin28    => bcm01

import gpiod
import enum
import asyncio
import logging
from logging.config import dictConfig
from typing import Optional, Any

from opentrons.system import nmcli
from opentrons.hardware_control.types import BoardRevision
from opentrons.drivers.rpi_drivers.gpio import GPIOCharDev


CHIP = gpiod.Chip('gpiochip0')

BLINK_ON_TIME = 0.25    # seconds
BLINK_OFF_TIME = 2      # seconds
NW_STATUS_POLL_SEC = 5

dictConfig({
        'version': 1,
        'disable_existing_loggers': False,
        'formatters': {
            'message_only': {'format': '%(levelname)s - %(message)s'}
        },
        'handlers': {
            'service': {
                'class': 'systemd.journal.JournalHandler',
                'level': logging.INFO,
                'formatter': 'message_only',
                'SYSLOG_IDENTIFIER': 'ot-status-leds',
            }
        },
        'loggers': {
            '__main__': {
                'level': logging.INFO,
                'handlers': ['service']
            }
        },
    })
log = logging.getLogger(__name__)


class LedLineOffset(int, enum.Enum):
    ETH = 22
    WIFI = 0
    HEARTBEAT = 25
    UNDEFINED = 1

    def __init__(self, offset):
        self._line = CHIP.get_line(offset)

    @property
    def line(self):
        return self._line


def init_leds() -> None:
    """ Sets LED pins as output. """
    for offset in list(LedLineOffset):
        offset.line.request(consumer='ot-status-leds',
                            type=gpiod.LINE_REQ_DIR_OUT)
        offset.line.set_value(0)


async def blink_heartbeat_led() -> None:
    """ Keep heartbeat LED blinking indefinitely. """
    hb_line = LedLineOffset.HEARTBEAT.line
    while True:
        hb_line.set_value(1)
        await asyncio.sleep(BLINK_ON_TIME)
        hb_line.set_value(0)
        await asyncio.sleep(BLINK_OFF_TIME)


async def update_nw_status_leds() -> None:
    """ Update WIFI & LinkLocal status LEDs according to NW status.

    Turn the LED ON when the respective network interface is UP.
    LED OFF when the interface is DOWN.
    """
    while True:
        eth_status = await nmcli.iface_info(nmcli.NETWORK_IFACES.ETH_LL)
        update_led(eth_status.get('ipAddress'), LedLineOffset.ETH.line)

        wifi_status = await nmcli.iface_info(nmcli.NETWORK_IFACES.WIFI)
        update_led(wifi_status.get('ipAddress'), LedLineOffset.WIFI.line)
        await asyncio.sleep(NW_STATUS_POLL_SEC)


def update_led(ip_status: Optional[str], line: Any):
    """ Set/ Reset the pin. """
    if ip_status is None:
        line.set_value(0)
    else:
        line.set_value(1)


def is_refresh_board():
    """ Check if this is a refresh board.

    Use the GPIOCharDev class to get board version and immediately close the
    gpiod chip so that the lines are released for use by Hardware Control.
    If GPIO isn't accessible, exit with exit-code 10 so that the service
    doesn't restart.
    """
    try:
        gpio = GPIOCharDev(chip_name='gpiochip0')
        board_rev = gpio._determine_board_revision()
        gpio._chip.close()
    except OSError:
        log.exception("Cannot access GPIO to determine board revision. "
                      "Aborting status lights service.")
        exit(10)

    return False if board_rev in (BoardRevision.OG, BoardRevision.UNKNOWN) \
        else True


async def main():
    """ If we have a refresh board, initialize LEDs
        and run status update tasks
    """
    if not is_refresh_board():
        log.info("Not a refresh board. Exiting status lights service.")
        exit(0)

    log.info("Refresh board found. Starting status LEDs service.")
    init_leds()
    heartbeat_task = asyncio.create_task(blink_heartbeat_led())
    update_nw_status_task = asyncio.create_task(update_nw_status_leds())

    await heartbeat_task
    await update_nw_status_task

asyncio.run(main())
